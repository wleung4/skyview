/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n/* harmony import */ var regenerator_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _scripts_airport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scripts/airport.js */ \"./src/scripts/airport.js\");\n/* harmony import */ var _scripts_flight_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scripts/flight.js */ \"./src/scripts/flight.js\");\n/* harmony import */ var _scripts_map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scripts/map.js */ \"./src/scripts/map.js\");\n\n\n\n\nconst searchForm = document.querySelector(\".home-search\");\nconst searchValue = document.getElementById(\"search\");\nconst flightTable = document.getElementById(\"flight-table\");\nconst mainPage = document.querySelector(\".main-page\");\nconst background = document.querySelector(\"#background\");\nlet departures;\nlet arrivals;\nlet locations;\nlet timer = null;\nsearchValue.addEventListener(\"keyup\", async e => {\n  clearTimeout(timer);\n  timer = setTimeout(async () => {\n    const matches = await (0,_scripts_airport_js__WEBPACK_IMPORTED_MODULE_1__.search)(searchValue.value);\n    console.log('searched');\n    console.log(matches);\n  }, 750);\n});\nsearchForm.addEventListener(\"submit\", async e => {\n  e.preventDefault();\n  const value = searchValue.value;\n  // airport ICAO\n  if (value === \"\") value = \"N/A\";\n  let airportInfo = await (0,_scripts_airport_js__WEBPACK_IMPORTED_MODULE_1__.getAirportInfo)(value);\n  while (!airportInfo) {\n    airportInfo = await (0,_scripts_airport_js__WEBPACK_IMPORTED_MODULE_1__.getAirportInfo)(value);\n  }\n  const airportICAO = airportInfo[0];\n  const airportLatitude = airportInfo[1];\n  const airportLongitude = airportInfo[2];\n  searchForm.style.display = 'none';\n  mainPage.style.display = \"flex\";\n  background.style.display = \"none\";\n\n  // 1 day = 86400, 1 hr = 3600\n  departures = await (0,_scripts_flight_js__WEBPACK_IMPORTED_MODULE_2__.getAirportDepartures)(airportICAO, (0,_scripts_flight_js__WEBPACK_IMPORTED_MODULE_2__.calculateTime)(4), (0,_scripts_flight_js__WEBPACK_IMPORTED_MODULE_2__.calculateTime)());\n  //console.log(\"Airport Departures from past 4 hrs to now: \", departures);\n\n  // callsign = Plane identifier i.e. DAL767\n  addFlightTable(departures);\n  (0,_scripts_map_js__WEBPACK_IMPORTED_MODULE_3__.addMap)([airportLongitude, airportLatitude], airportICAO);\n  // get arrival aircraft info for past day\n  //arrivals = await getAirportArrivals(airportICAO, calculateTime() - 86400*2, calculateTime());\n  // console.log(\"Airport Arrivals from 2 days ago:\", arrivals);\n\n  // console.log(\"Arrivals: \");\n  // arrivals.forEach(arrival => console.log(`Plane number: ${arrival.callsign}`, `ICAO: ${arrival.icao24}`));\n\n  // console.log(\"Arrivals Aircraft info for past 2 days:\")\n  // for(let i = 0; i < arrivals.length; i++){\n  // \tconst info = await getAircraft(arrivals[i].icao24, calculateTime() - 86400*2, calculateTime());\n  // }\n});\n\nconst addFlightTable = async info => {\n  let table = document.createElement(\"table\");\n  let tableBody = document.createElement(\"tbody\");\n\n  //top column name row\n  const colRow = document.createElement(\"tr\");\n  colRow.classList.add(\"header\");\n  const callsignCol = document.createElement(\"td\");\n  callsignCol.textContent = \"Plane\";\n  const departureTimeCol = document.createElement(\"td\");\n  departureTimeCol.textContent = \"Time Departed\";\n  const departureAirportCol = document.createElement(\"td\");\n  departureAirportCol.textContent = \"From\";\n  const arrivalAirportCol = document.createElement(\"td\");\n  arrivalAirportCol.textContent = \"To\";\n  colRow.appendChild(callsignCol);\n  colRow.appendChild(departureTimeCol);\n  colRow.appendChild(departureAirportCol);\n  colRow.appendChild(arrivalAirportCol);\n  tableBody.appendChild(colRow);\n\n  // actual data\n  for (let i = 0; i < info.length; i++) {\n    const row = document.createElement(\"tr\");\n    const callsign = document.createElement(\"td\");\n    callsign.textContent = info[i].callsign;\n    callsign.classList.add(\"clickable\");\n\n    // allows clickable planes => gets location info about clicked plane\n    callsign.addEventListener(\"click\", async e => {\n      e.stopPropagation();\n      locations = (0,_scripts_flight_js__WEBPACK_IMPORTED_MODULE_2__.getFlightLocation)(info[i].icao24);\n      (0,_scripts_map_js__WEBPACK_IMPORTED_MODULE_3__.drawPath)(locations, callsign.textContent);\n    });\n    const departureTime = document.createElement(\"td\");\n    const date = new Date(info[i].firstSeen * 1000).toString();\n    departureTime.textContent = date.slice(0, 28);\n    const departureAirport = document.createElement(\"td\");\n    departureAirport.textContent = info[i].estDepartureAirport;\n    let arrivalAirport = document.createElement(\"td\");\n    if (info[i].estArrivalAirport === null) {\n      arrivalAirport.textContent = \"TBD\";\n    } else {\n      arrivalAirport.textContent = info[i].estArrivalAirport;\n    }\n    row.appendChild(callsign);\n    row.appendChild(departureTime);\n    row.appendChild(departureAirport);\n    row.appendChild(arrivalAirport);\n    tableBody.appendChild(row);\n  }\n  table.appendChild(tableBody);\n  flightTable.appendChild(table);\n  flightTable.classList.add(\"table-style\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRDO0FBQ2tCO0FBQytCO0FBQ3pDO0FBRXBELE1BQU1RLFVBQVUsR0FBR0MsUUFBUSxDQUFDQyxhQUFhLENBQUMsY0FBYyxDQUFDO0FBQ3pELE1BQU1DLFdBQVcsR0FBR0YsUUFBUSxDQUFDRyxjQUFjLENBQUMsUUFBUSxDQUFDO0FBQ3JELE1BQU1DLFdBQVcsR0FBR0osUUFBUSxDQUFDRyxjQUFjLENBQUMsY0FBYyxDQUFDO0FBQzNELE1BQU1FLFFBQVEsR0FBR0wsUUFBUSxDQUFDQyxhQUFhLENBQUMsWUFBWSxDQUFDO0FBQ3JELE1BQU1LLFVBQVUsR0FBR04sUUFBUSxDQUFDQyxhQUFhLENBQUMsYUFBYSxDQUFDO0FBRXhELElBQUlNLFVBQVU7QUFDZCxJQUFJQyxRQUFRO0FBQ1osSUFBSUMsU0FBUztBQUNiLElBQUlDLEtBQUssR0FBRyxJQUFJO0FBQ2hCUixXQUFXLENBQUNTLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxNQUFNQyxDQUFDLElBQUs7RUFDakRDLFlBQVksQ0FBQ0gsS0FBSyxDQUFDO0VBQ25CQSxLQUFLLEdBQUdJLFVBQVUsQ0FBQyxZQUFTO0lBQzNCLE1BQU1DLE9BQU8sR0FBRyxNQUFNdEIsMkRBQU0sQ0FBQ1MsV0FBVyxDQUFDYyxLQUFLLENBQUM7SUFDL0NDLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDLFVBQVUsQ0FBQztJQUN2QkQsT0FBTyxDQUFDQyxHQUFHLENBQUNILE9BQU8sQ0FBQztFQUNyQixDQUFDLEVBQUUsR0FBRyxDQUFDO0FBQ1IsQ0FBQyxDQUFDO0FBRUZoQixVQUFVLENBQUNZLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxNQUFNQyxDQUFDLElBQUs7RUFDakRBLENBQUMsQ0FBQ08sY0FBYyxDQUFDLENBQUM7RUFFbEIsTUFBTUgsS0FBSyxHQUFHZCxXQUFXLENBQUNjLEtBQUs7RUFDL0I7RUFDQSxJQUFHQSxLQUFLLEtBQUssRUFBRSxFQUFFQSxLQUFLLEdBQUcsS0FBSztFQUM5QixJQUFJSSxXQUFXLEdBQUcsTUFBTTVCLG1FQUFjLENBQUN3QixLQUFLLENBQUM7RUFDN0MsT0FBTyxDQUFDSSxXQUFXLEVBQUU7SUFDcEJBLFdBQVcsR0FBRyxNQUFNNUIsbUVBQWMsQ0FBQ3dCLEtBQUssQ0FBQztFQUMxQztFQUNBLE1BQU1LLFdBQVcsR0FBR0QsV0FBVyxDQUFDLENBQUMsQ0FBQztFQUNsQyxNQUFNRSxlQUFlLEdBQUdGLFdBQVcsQ0FBQyxDQUFDLENBQUM7RUFDdEMsTUFBTUcsZ0JBQWdCLEdBQUdILFdBQVcsQ0FBQyxDQUFDLENBQUM7RUFDdkNyQixVQUFVLENBQUN5QixLQUFLLENBQUNDLE9BQU8sR0FBRyxNQUFNO0VBQ2pDcEIsUUFBUSxDQUFDbUIsS0FBSyxDQUFDQyxPQUFPLEdBQUcsTUFBTTtFQUMvQm5CLFVBQVUsQ0FBQ2tCLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLE1BQU07O0VBRWpDO0VBQ0FsQixVQUFVLEdBQUcsTUFBTVosd0VBQW9CLENBQUMwQixXQUFXLEVBQUUzQixpRUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFQSxpRUFBYSxDQUFDLENBQUMsQ0FBQztFQUN2Rjs7RUFFQTtFQUNBZ0MsY0FBYyxDQUFDbkIsVUFBVSxDQUFDO0VBQzFCVix1REFBTSxDQUFDLENBQUMwQixnQkFBZ0IsRUFBRUQsZUFBZSxDQUFDLEVBQUVELFdBQVcsQ0FBQztFQUN4RDtFQUNBO0VBQ0E7O0VBRUE7RUFDQTs7RUFFQTtFQUNBO0VBQ0E7RUFDQTtBQUNELENBQUMsQ0FBQzs7QUFFRixNQUFNSyxjQUFjLEdBQUcsTUFBTUMsSUFBSSxJQUFLO0VBQ3JDLElBQUlDLEtBQUssR0FBRzVCLFFBQVEsQ0FBQzZCLGFBQWEsQ0FBQyxPQUFPLENBQUM7RUFDM0MsSUFBSUMsU0FBUyxHQUFHOUIsUUFBUSxDQUFDNkIsYUFBYSxDQUFDLE9BQU8sQ0FBQzs7RUFFL0M7RUFDQSxNQUFNRSxNQUFNLEdBQUcvQixRQUFRLENBQUM2QixhQUFhLENBQUMsSUFBSSxDQUFDO0VBQzNDRSxNQUFNLENBQUNDLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDLFFBQVEsQ0FBQztFQUM5QixNQUFNQyxXQUFXLEdBQUdsQyxRQUFRLENBQUM2QixhQUFhLENBQUMsSUFBSSxDQUFDO0VBQ2hESyxXQUFXLENBQUNDLFdBQVcsR0FBRyxPQUFPO0VBQ2pDLE1BQU1DLGdCQUFnQixHQUFHcEMsUUFBUSxDQUFDNkIsYUFBYSxDQUFDLElBQUksQ0FBQztFQUNyRE8sZ0JBQWdCLENBQUNELFdBQVcsR0FBRyxlQUFlO0VBQzlDLE1BQU1FLG1CQUFtQixHQUFHckMsUUFBUSxDQUFDNkIsYUFBYSxDQUFDLElBQUksQ0FBQztFQUN4RFEsbUJBQW1CLENBQUNGLFdBQVcsR0FBRyxNQUFNO0VBQ3hDLE1BQU1HLGlCQUFpQixHQUFHdEMsUUFBUSxDQUFDNkIsYUFBYSxDQUFDLElBQUksQ0FBQztFQUN0RFMsaUJBQWlCLENBQUNILFdBQVcsR0FBRyxJQUFJO0VBRXBDSixNQUFNLENBQUNRLFdBQVcsQ0FBQ0wsV0FBVyxDQUFDO0VBQy9CSCxNQUFNLENBQUNRLFdBQVcsQ0FBQ0gsZ0JBQWdCLENBQUM7RUFDcENMLE1BQU0sQ0FBQ1EsV0FBVyxDQUFDRixtQkFBbUIsQ0FBQztFQUN2Q04sTUFBTSxDQUFDUSxXQUFXLENBQUNELGlCQUFpQixDQUFDO0VBQ3JDUixTQUFTLENBQUNTLFdBQVcsQ0FBQ1IsTUFBTSxDQUFDOztFQUU3QjtFQUNBLEtBQUksSUFBSVMsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHYixJQUFJLENBQUNjLE1BQU0sRUFBRUQsQ0FBQyxFQUFFLEVBQUM7SUFDbkMsTUFBTUUsR0FBRyxHQUFHMUMsUUFBUSxDQUFDNkIsYUFBYSxDQUFDLElBQUksQ0FBQztJQUV4QyxNQUFNYyxRQUFRLEdBQUczQyxRQUFRLENBQUM2QixhQUFhLENBQUMsSUFBSSxDQUFDO0lBQzdDYyxRQUFRLENBQUNSLFdBQVcsR0FBR1IsSUFBSSxDQUFDYSxDQUFDLENBQUMsQ0FBQ0csUUFBUTtJQUN2Q0EsUUFBUSxDQUFDWCxTQUFTLENBQUNDLEdBQUcsQ0FBQyxXQUFXLENBQUM7O0lBRW5DO0lBQ0FVLFFBQVEsQ0FBQ2hDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxNQUFNQyxDQUFDLElBQUs7TUFDOUNBLENBQUMsQ0FBQ2dDLGVBQWUsQ0FBQyxDQUFDO01BQ25CbkMsU0FBUyxHQUFHYixxRUFBaUIsQ0FBQytCLElBQUksQ0FBQ2EsQ0FBQyxDQUFDLENBQUNLLE1BQU0sQ0FBQztNQUM3Qy9DLHlEQUFRLENBQUNXLFNBQVMsRUFBRWtDLFFBQVEsQ0FBQ1IsV0FBVyxDQUFDO0lBQzFDLENBQUMsQ0FBQztJQUVGLE1BQU1XLGFBQWEsR0FBRzlDLFFBQVEsQ0FBQzZCLGFBQWEsQ0FBQyxJQUFJLENBQUM7SUFDbEQsTUFBTWtCLElBQUksR0FBRyxJQUFJQyxJQUFJLENBQUNyQixJQUFJLENBQUNhLENBQUMsQ0FBQyxDQUFDUyxTQUFTLEdBQUcsSUFBSSxDQUFDLENBQUNDLFFBQVEsQ0FBQyxDQUFDO0lBQzFESixhQUFhLENBQUNYLFdBQVcsR0FBR1ksSUFBSSxDQUFDSSxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUU3QyxNQUFNQyxnQkFBZ0IsR0FBR3BELFFBQVEsQ0FBQzZCLGFBQWEsQ0FBQyxJQUFJLENBQUM7SUFDckR1QixnQkFBZ0IsQ0FBQ2pCLFdBQVcsR0FBR1IsSUFBSSxDQUFDYSxDQUFDLENBQUMsQ0FBQ2EsbUJBQW1CO0lBRTFELElBQUlDLGNBQWMsR0FBR3RELFFBQVEsQ0FBQzZCLGFBQWEsQ0FBQyxJQUFJLENBQUM7SUFDakQsSUFBR0YsSUFBSSxDQUFDYSxDQUFDLENBQUMsQ0FBQ2UsaUJBQWlCLEtBQUssSUFBSSxFQUFDO01BQ3JDRCxjQUFjLENBQUNuQixXQUFXLEdBQUcsS0FBSztJQUNuQyxDQUFDLE1BQU07TUFDTm1CLGNBQWMsQ0FBQ25CLFdBQVcsR0FBR1IsSUFBSSxDQUFDYSxDQUFDLENBQUMsQ0FBQ2UsaUJBQWlCO0lBQ3ZEO0lBRUFiLEdBQUcsQ0FBQ0gsV0FBVyxDQUFDSSxRQUFRLENBQUM7SUFDekJELEdBQUcsQ0FBQ0gsV0FBVyxDQUFDTyxhQUFhLENBQUM7SUFDOUJKLEdBQUcsQ0FBQ0gsV0FBVyxDQUFDYSxnQkFBZ0IsQ0FBQztJQUNqQ1YsR0FBRyxDQUFDSCxXQUFXLENBQUNlLGNBQWMsQ0FBQztJQUUvQnhCLFNBQVMsQ0FBQ1MsV0FBVyxDQUFDRyxHQUFHLENBQUM7RUFDM0I7RUFDQWQsS0FBSyxDQUFDVyxXQUFXLENBQUNULFNBQVMsQ0FBQztFQUM1QjFCLFdBQVcsQ0FBQ21DLFdBQVcsQ0FBQ1gsS0FBSyxDQUFDO0VBQzlCeEIsV0FBVyxDQUFDNEIsU0FBUyxDQUFDQyxHQUFHLENBQUMsYUFBYSxDQUFDO0FBQ3pDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za3l2aWV3Ly4vc3JjL2luZGV4LmpzP2I2MzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXN5bmMgfSBmcm9tICdyZWdlbmVyYXRvci1ydW50aW1lJztcbmltcG9ydCB7IGdldEFpcnBvcnRJbmZvLCBzZWFyY2ggfSBmcm9tICcuL3NjcmlwdHMvYWlycG9ydC5qcyc7XG5pbXBvcnQgeyBjYWxjdWxhdGVUaW1lLCBnZXRBaXJwb3J0RGVwYXJ0dXJlcywgZ2V0RmxpZ2h0TG9jYXRpb24gfSBmcm9tICcuL3NjcmlwdHMvZmxpZ2h0LmpzJztcbmltcG9ydCB7IGFkZE1hcCwgZHJhd1BhdGggfSBmcm9tICcuL3NjcmlwdHMvbWFwLmpzJztcblxuY29uc3Qgc2VhcmNoRm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuaG9tZS1zZWFyY2hcIik7XG5jb25zdCBzZWFyY2hWYWx1ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2VhcmNoXCIpO1xuY29uc3QgZmxpZ2h0VGFibGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsaWdodC10YWJsZVwiKTtcbmNvbnN0IG1haW5QYWdlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5tYWluLXBhZ2VcIik7XG5jb25zdCBiYWNrZ3JvdW5kID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNiYWNrZ3JvdW5kXCIpO1xuXG5sZXQgZGVwYXJ0dXJlcztcbmxldCBhcnJpdmFscztcbmxldCBsb2NhdGlvbnM7XG5sZXQgdGltZXIgPSBudWxsO1xuc2VhcmNoVmFsdWUuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGFzeW5jKGUpID0+IHtcblx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0dGltZXIgPSBzZXRUaW1lb3V0KGFzeW5jKCk9Pntcblx0XHRjb25zdCBtYXRjaGVzID0gYXdhaXQgc2VhcmNoKHNlYXJjaFZhbHVlLnZhbHVlKTtcblx0XHRjb25zb2xlLmxvZygnc2VhcmNoZWQnKTtcblx0XHRjb25zb2xlLmxvZyhtYXRjaGVzKTtcblx0fSwgNzUwKTtcbn0pIFxuXG5zZWFyY2hGb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgYXN5bmMoZSkgPT4ge1xuXHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0Y29uc3QgdmFsdWUgPSBzZWFyY2hWYWx1ZS52YWx1ZTtcblx0Ly8gYWlycG9ydCBJQ0FPXG5cdGlmKHZhbHVlID09PSBcIlwiKSB2YWx1ZSA9IFwiTi9BXCI7XG5cdGxldCBhaXJwb3J0SW5mbyA9IGF3YWl0IGdldEFpcnBvcnRJbmZvKHZhbHVlKTtcblx0d2hpbGUgKCFhaXJwb3J0SW5mbykge1xuXHRcdGFpcnBvcnRJbmZvID0gYXdhaXQgZ2V0QWlycG9ydEluZm8odmFsdWUpO1xuXHR9XG5cdGNvbnN0IGFpcnBvcnRJQ0FPID0gYWlycG9ydEluZm9bMF07XG5cdGNvbnN0IGFpcnBvcnRMYXRpdHVkZSA9IGFpcnBvcnRJbmZvWzFdO1xuXHRjb25zdCBhaXJwb3J0TG9uZ2l0dWRlID0gYWlycG9ydEluZm9bMl07XG5cdHNlYXJjaEZvcm0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0bWFpblBhZ2Uuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuXHRiYWNrZ3JvdW5kLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuXHQvLyAxIGRheSA9IDg2NDAwLCAxIGhyID0gMzYwMFxuXHRkZXBhcnR1cmVzID0gYXdhaXQgZ2V0QWlycG9ydERlcGFydHVyZXMoYWlycG9ydElDQU8sIGNhbGN1bGF0ZVRpbWUoNCksIGNhbGN1bGF0ZVRpbWUoKSk7XG5cdC8vY29uc29sZS5sb2coXCJBaXJwb3J0IERlcGFydHVyZXMgZnJvbSBwYXN0IDQgaHJzIHRvIG5vdzogXCIsIGRlcGFydHVyZXMpO1xuXHRcblx0Ly8gY2FsbHNpZ24gPSBQbGFuZSBpZGVudGlmaWVyIGkuZS4gREFMNzY3XG5cdGFkZEZsaWdodFRhYmxlKGRlcGFydHVyZXMpO1xuXHRhZGRNYXAoW2FpcnBvcnRMb25naXR1ZGUsIGFpcnBvcnRMYXRpdHVkZV0sIGFpcnBvcnRJQ0FPKTtcblx0Ly8gZ2V0IGFycml2YWwgYWlyY3JhZnQgaW5mbyBmb3IgcGFzdCBkYXlcblx0Ly9hcnJpdmFscyA9IGF3YWl0IGdldEFpcnBvcnRBcnJpdmFscyhhaXJwb3J0SUNBTywgY2FsY3VsYXRlVGltZSgpIC0gODY0MDAqMiwgY2FsY3VsYXRlVGltZSgpKTtcblx0Ly8gY29uc29sZS5sb2coXCJBaXJwb3J0IEFycml2YWxzIGZyb20gMiBkYXlzIGFnbzpcIiwgYXJyaXZhbHMpO1xuXG5cdC8vIGNvbnNvbGUubG9nKFwiQXJyaXZhbHM6IFwiKTtcblx0Ly8gYXJyaXZhbHMuZm9yRWFjaChhcnJpdmFsID0+IGNvbnNvbGUubG9nKGBQbGFuZSBudW1iZXI6ICR7YXJyaXZhbC5jYWxsc2lnbn1gLCBgSUNBTzogJHthcnJpdmFsLmljYW8yNH1gKSk7XG5cblx0Ly8gY29uc29sZS5sb2coXCJBcnJpdmFscyBBaXJjcmFmdCBpbmZvIGZvciBwYXN0IDIgZGF5czpcIilcblx0Ly8gZm9yKGxldCBpID0gMDsgaSA8IGFycml2YWxzLmxlbmd0aDsgaSsrKXtcblx0Ly8gXHRjb25zdCBpbmZvID0gYXdhaXQgZ2V0QWlyY3JhZnQoYXJyaXZhbHNbaV0uaWNhbzI0LCBjYWxjdWxhdGVUaW1lKCkgLSA4NjQwMCoyLCBjYWxjdWxhdGVUaW1lKCkpO1xuXHQvLyB9XG59KTtcblxuY29uc3QgYWRkRmxpZ2h0VGFibGUgPSBhc3luYyhpbmZvKSA9PiB7XG5cdGxldCB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKTtcblx0bGV0IHRhYmxlQm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiKTtcblxuXHQvL3RvcCBjb2x1bW4gbmFtZSByb3dcblx0Y29uc3QgY29sUm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpO1xuXHRjb2xSb3cuY2xhc3NMaXN0LmFkZChcImhlYWRlclwiKTtcblx0Y29uc3QgY2FsbHNpZ25Db2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG5cdGNhbGxzaWduQ29sLnRleHRDb250ZW50ID0gXCJQbGFuZVwiO1xuXHRjb25zdCBkZXBhcnR1cmVUaW1lQ29sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuXHRkZXBhcnR1cmVUaW1lQ29sLnRleHRDb250ZW50ID0gXCJUaW1lIERlcGFydGVkXCI7XG5cdGNvbnN0IGRlcGFydHVyZUFpcnBvcnRDb2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG5cdGRlcGFydHVyZUFpcnBvcnRDb2wudGV4dENvbnRlbnQgPSBcIkZyb21cIjtcblx0Y29uc3QgYXJyaXZhbEFpcnBvcnRDb2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG5cdGFycml2YWxBaXJwb3J0Q29sLnRleHRDb250ZW50ID0gXCJUb1wiO1xuXG5cdGNvbFJvdy5hcHBlbmRDaGlsZChjYWxsc2lnbkNvbCk7XG5cdGNvbFJvdy5hcHBlbmRDaGlsZChkZXBhcnR1cmVUaW1lQ29sKTtcblx0Y29sUm93LmFwcGVuZENoaWxkKGRlcGFydHVyZUFpcnBvcnRDb2wpO1xuXHRjb2xSb3cuYXBwZW5kQ2hpbGQoYXJyaXZhbEFpcnBvcnRDb2wpO1xuXHR0YWJsZUJvZHkuYXBwZW5kQ2hpbGQoY29sUm93KTtcblxuXHQvLyBhY3R1YWwgZGF0YVxuXHRmb3IobGV0IGkgPSAwOyBpIDwgaW5mby5sZW5ndGg7IGkrKyl7XG5cdFx0Y29uc3Qgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpO1xuXG5cdFx0Y29uc3QgY2FsbHNpZ24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG5cdFx0Y2FsbHNpZ24udGV4dENvbnRlbnQgPSBpbmZvW2ldLmNhbGxzaWduO1xuXHRcdGNhbGxzaWduLmNsYXNzTGlzdC5hZGQoXCJjbGlja2FibGVcIik7XG5cblx0XHQvLyBhbGxvd3MgY2xpY2thYmxlIHBsYW5lcyA9PiBnZXRzIGxvY2F0aW9uIGluZm8gYWJvdXQgY2xpY2tlZCBwbGFuZVxuXHRcdGNhbGxzaWduLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBhc3luYyhlKSA9PiB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0bG9jYXRpb25zID0gZ2V0RmxpZ2h0TG9jYXRpb24oaW5mb1tpXS5pY2FvMjQpO1xuXHRcdFx0ZHJhd1BhdGgobG9jYXRpb25zLCBjYWxsc2lnbi50ZXh0Q29udGVudCk7XG5cdFx0fSlcblxuXHRcdGNvbnN0IGRlcGFydHVyZVRpbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG5cdFx0Y29uc3QgZGF0ZSA9IG5ldyBEYXRlKGluZm9baV0uZmlyc3RTZWVuICogMTAwMCkudG9TdHJpbmcoKTtcblx0XHRkZXBhcnR1cmVUaW1lLnRleHRDb250ZW50ID0gZGF0ZS5zbGljZSgwLCAyOCk7XG5cblx0XHRjb25zdCBkZXBhcnR1cmVBaXJwb3J0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuXHRcdGRlcGFydHVyZUFpcnBvcnQudGV4dENvbnRlbnQgPSBpbmZvW2ldLmVzdERlcGFydHVyZUFpcnBvcnQ7XG5cblx0XHRsZXQgYXJyaXZhbEFpcnBvcnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG5cdFx0aWYoaW5mb1tpXS5lc3RBcnJpdmFsQWlycG9ydCA9PT0gbnVsbCl7XG5cdFx0XHRhcnJpdmFsQWlycG9ydC50ZXh0Q29udGVudCA9IFwiVEJEXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFycml2YWxBaXJwb3J0LnRleHRDb250ZW50ID0gaW5mb1tpXS5lc3RBcnJpdmFsQWlycG9ydDtcblx0XHR9XG5cblx0XHRyb3cuYXBwZW5kQ2hpbGQoY2FsbHNpZ24pO1xuXHRcdHJvdy5hcHBlbmRDaGlsZChkZXBhcnR1cmVUaW1lKTtcblx0XHRyb3cuYXBwZW5kQ2hpbGQoZGVwYXJ0dXJlQWlycG9ydCk7XG5cdFx0cm93LmFwcGVuZENoaWxkKGFycml2YWxBaXJwb3J0KTtcblxuXHRcdHRhYmxlQm9keS5hcHBlbmRDaGlsZChyb3cpO1xuXHR9XG5cdHRhYmxlLmFwcGVuZENoaWxkKHRhYmxlQm9keSk7XG5cdGZsaWdodFRhYmxlLmFwcGVuZENoaWxkKHRhYmxlKTtcblx0ZmxpZ2h0VGFibGUuY2xhc3NMaXN0LmFkZChcInRhYmxlLXN0eWxlXCIpO1xufVxuXG4iXSwibmFtZXMiOlsiYXN5bmMiLCJnZXRBaXJwb3J0SW5mbyIsInNlYXJjaCIsImNhbGN1bGF0ZVRpbWUiLCJnZXRBaXJwb3J0RGVwYXJ0dXJlcyIsImdldEZsaWdodExvY2F0aW9uIiwiYWRkTWFwIiwiZHJhd1BhdGgiLCJzZWFyY2hGb3JtIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwic2VhcmNoVmFsdWUiLCJnZXRFbGVtZW50QnlJZCIsImZsaWdodFRhYmxlIiwibWFpblBhZ2UiLCJiYWNrZ3JvdW5kIiwiZGVwYXJ0dXJlcyIsImFycml2YWxzIiwibG9jYXRpb25zIiwidGltZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJtYXRjaGVzIiwidmFsdWUiLCJjb25zb2xlIiwibG9nIiwicHJldmVudERlZmF1bHQiLCJhaXJwb3J0SW5mbyIsImFpcnBvcnRJQ0FPIiwiYWlycG9ydExhdGl0dWRlIiwiYWlycG9ydExvbmdpdHVkZSIsInN0eWxlIiwiZGlzcGxheSIsImFkZEZsaWdodFRhYmxlIiwiaW5mbyIsInRhYmxlIiwiY3JlYXRlRWxlbWVudCIsInRhYmxlQm9keSIsImNvbFJvdyIsImNsYXNzTGlzdCIsImFkZCIsImNhbGxzaWduQ29sIiwidGV4dENvbnRlbnQiLCJkZXBhcnR1cmVUaW1lQ29sIiwiZGVwYXJ0dXJlQWlycG9ydENvbCIsImFycml2YWxBaXJwb3J0Q29sIiwiYXBwZW5kQ2hpbGQiLCJpIiwibGVuZ3RoIiwicm93IiwiY2FsbHNpZ24iLCJzdG9wUHJvcGFnYXRpb24iLCJpY2FvMjQiLCJkZXBhcnR1cmVUaW1lIiwiZGF0ZSIsIkRhdGUiLCJmaXJzdFNlZW4iLCJ0b1N0cmluZyIsInNsaWNlIiwiZGVwYXJ0dXJlQWlycG9ydCIsImVzdERlcGFydHVyZUFpcnBvcnQiLCJhcnJpdmFsQWlycG9ydCIsImVzdEFycml2YWxBaXJwb3J0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/scripts/airport.js":
/*!********************************!*\
  !*** ./src/scripts/airport.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAirportInfo: function() { return /* binding */ getAirportInfo; },\n/* harmony export */   search: function() { return /* binding */ search; }\n/* harmony export */ });\nconst airports = [];\nconst getAirportInfo = async airportName => {\n  // \"country_code\",\"region_name\",\"iata\",\"icao\",\"airport\",\"latitude\",\"longitude\"\n  const res = await fetch('../iata-icao.csv');\n  const data = await res.text();\n  const rows = data.split('\\n').slice(1);\n  rows.forEach(ele => {\n    const row = ele.split(\",\");\n    const country_code = row[0].slice(1, row[0].length - 1);\n    const region_name = row[1].slice(1, row[1].length - 1);\n    const iata = row[2].slice(1, row[2].length - 1);\n    const icao = row[3].slice(1, row[3].length - 1);\n    const airport = row[4].slice(1, row[4].length - 1);\n    const latitude = row[5].slice(1, row[5].length - 1);\n    const longitude = row[6].slice(1, row[6].length - 2);\n    airports.push({\n      airport: airport,\n      country_code: country_code,\n      region_name: region_name,\n      iata: iata,\n      icao: icao,\n      latitude: latitude,\n      longitude: longitude\n    });\n  });\n  // transform array of objects into single object where keys is the airport name\n  const airportObj = airports.reduce((obj, item) => Object.assign(obj, {\n    [item.airport]: item\n  }, {}));\n  //console.log(airportObj); // search for airport using airport name key, can key into\n  if (airportObj[airportName]) {\n    return [airportObj[airportName].icao, airportObj[airportName].latitude, airportObj[airportName].longitude];\n  } else {\n    return undefined;\n  }\n};\nconst search = async input => {\n  await getAirportInfo(input);\n  const results = [];\n  airports.forEach(airportObj => {\n    if (airportObj.airport.toLowerCase().includes(input.toLowerCase())) {\n      if (!results.includes(airportObj.airport)) results.push(airportObj.airport);\n    }\n  });\n  return results;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBTTtJQUNOLE9BQU9RLFNBQVM7RUFDakI7QUFDRCxDQUFDO0FBRU0sTUFBTUMsTUFBTSxHQUFHLE1BQU1DLEtBQUssSUFBSztFQUNyQyxNQUFNN0IsY0FBYyxDQUFDNkIsS0FBSyxDQUFDO0VBQzNCLE1BQU1DLE9BQU8sR0FBRyxFQUFFO0VBQ2xCL0IsUUFBUSxDQUFDVSxPQUFPLENBQUNZLFVBQVUsSUFBSTtJQUM5QixJQUFHQSxVQUFVLENBQUNKLE9BQU8sQ0FBQ2MsV0FBVyxDQUFDLENBQUMsQ0FBQ0MsUUFBUSxDQUFDSCxLQUFLLENBQUNFLFdBQVcsQ0FBQyxDQUFDLENBQUMsRUFBRTtNQUNsRSxJQUFHLENBQUNELE9BQU8sQ0FBQ0UsUUFBUSxDQUFDWCxVQUFVLENBQUNKLE9BQU8sQ0FBQyxFQUFFYSxPQUFPLENBQUNWLElBQUksQ0FBQ0MsVUFBVSxDQUFDSixPQUFPLENBQUM7SUFDM0U7RUFDRCxDQUFDLENBQUM7RUFDRixPQUFPYSxPQUFPO0FBQ2YsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NreXZpZXcvLi9zcmMvc2NyaXB0cy9haXJwb3J0LmpzPzI0ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYWlycG9ydHMgPSBbXTtcbmV4cG9ydCBjb25zdCBnZXRBaXJwb3J0SW5mbyA9IGFzeW5jIChhaXJwb3J0TmFtZSkgPT4ge1xuXHQvLyBcImNvdW50cnlfY29kZVwiLFwicmVnaW9uX25hbWVcIixcImlhdGFcIixcImljYW9cIixcImFpcnBvcnRcIixcImxhdGl0dWRlXCIsXCJsb25naXR1ZGVcIlxuXHRjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnLi4vaWF0YS1pY2FvLmNzdicpO1xuXHRjb25zdCBkYXRhID0gYXdhaXQgcmVzLnRleHQoKTtcblx0Y29uc3Qgcm93cyA9IGRhdGEuc3BsaXQoJ1xcbicpLnNsaWNlKDEpO1xuXG5cdHJvd3MuZm9yRWFjaCgoZWxlKT0+e1xuXHRcdGNvbnN0IHJvdyA9IGVsZS5zcGxpdChcIixcIik7XG5cdFx0Y29uc3QgY291bnRyeV9jb2RlID0gcm93WzBdLnNsaWNlKDEsIHJvd1swXS5sZW5ndGggLSAxKTtcblx0XHRjb25zdCByZWdpb25fbmFtZSA9IHJvd1sxXS5zbGljZSgxLCByb3dbMV0ubGVuZ3RoIC0gMSk7XG5cdFx0Y29uc3QgaWF0YSA9IHJvd1syXS5zbGljZSgxLCByb3dbMl0ubGVuZ3RoIC0gMSk7XG5cdFx0Y29uc3QgaWNhbyA9IHJvd1szXS5zbGljZSgxLCByb3dbM10ubGVuZ3RoIC0gMSk7XG5cdFx0Y29uc3QgYWlycG9ydCA9IHJvd1s0XS5zbGljZSgxLCByb3dbNF0ubGVuZ3RoIC0gMSk7XG5cdFx0Y29uc3QgbGF0aXR1ZGUgPSByb3dbNV0uc2xpY2UoMSwgcm93WzVdLmxlbmd0aCAtIDEpO1xuXHRcdGNvbnN0IGxvbmdpdHVkZSA9IHJvd1s2XS5zbGljZSgxLCByb3dbNl0ubGVuZ3RoIC0gMik7XG5cdFx0YWlycG9ydHMucHVzaCh7YWlycG9ydDogYWlycG9ydCxjb3VudHJ5X2NvZGU6IGNvdW50cnlfY29kZSwgcmVnaW9uX25hbWU6IHJlZ2lvbl9uYW1lLCBpYXRhOiBpYXRhLCBcblx0XHRcdGljYW86IGljYW8sIGxhdGl0dWRlOiBsYXRpdHVkZSwgbG9uZ2l0dWRlOiBsb25naXR1ZGV9KTtcblx0fSlcblx0Ly8gdHJhbnNmb3JtIGFycmF5IG9mIG9iamVjdHMgaW50byBzaW5nbGUgb2JqZWN0IHdoZXJlIGtleXMgaXMgdGhlIGFpcnBvcnQgbmFtZVxuXHRjb25zdCBhaXJwb3J0T2JqID0gYWlycG9ydHMucmVkdWNlKChvYmosIGl0ZW0pID0+IE9iamVjdC5hc3NpZ24ob2JqLCB7W2l0ZW0uYWlycG9ydF06aXRlbX0sIHt9KSk7XG5cdC8vY29uc29sZS5sb2coYWlycG9ydE9iaik7IC8vIHNlYXJjaCBmb3IgYWlycG9ydCB1c2luZyBhaXJwb3J0IG5hbWUga2V5LCBjYW4ga2V5IGludG9cblx0aWYgKGFpcnBvcnRPYmpbYWlycG9ydE5hbWVdKSB7XG5cdFx0cmV0dXJuIFthaXJwb3J0T2JqW2FpcnBvcnROYW1lXS5pY2FvLCBhaXJwb3J0T2JqW2FpcnBvcnROYW1lXS5sYXRpdHVkZSwgYWlycG9ydE9ialthaXJwb3J0TmFtZV0ubG9uZ2l0dWRlXTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG59XG5cbmV4cG9ydCBjb25zdCBzZWFyY2ggPSBhc3luYyhpbnB1dCkgPT4ge1xuXHRhd2FpdCBnZXRBaXJwb3J0SW5mbyhpbnB1dCk7XG5cdGNvbnN0IHJlc3VsdHMgPSBbXTtcblx0YWlycG9ydHMuZm9yRWFjaChhaXJwb3J0T2JqID0+IHtcblx0XHRpZihhaXJwb3J0T2JqLmFpcnBvcnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhpbnB1dC50b0xvd2VyQ2FzZSgpKSkge1xuXHRcdFx0aWYoIXJlc3VsdHMuaW5jbHVkZXMoYWlycG9ydE9iai5haXJwb3J0KSkgcmVzdWx0cy5wdXNoKGFpcnBvcnRPYmouYWlycG9ydCk7XG5cdFx0fVxuXHR9KVxuXHRyZXR1cm4gcmVzdWx0cztcdFxufVxuXG4iXSwibmFtZXMiOlsiYWlycG9ydHMiLCJnZXRBaXJwb3J0SW5mbyIsImFpcnBvcnROYW1lIiwicmVzIiwiZmV0Y2giLCJkYXRhIiwidGV4dCIsInJvd3MiLCJzcGxpdCIsInNsaWNlIiwiZm9yRWFjaCIsImVsZSIsInJvdyIsImNvdW50cnlfY29kZSIsImxlbmd0aCIsInJlZ2lvbl9uYW1lIiwiaWF0YSIsImljYW8iLCJhaXJwb3J0IiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJwdXNoIiwiYWlycG9ydE9iaiIsInJlZHVjZSIsIm9iaiIsIml0ZW0iLCJPYmplY3QiLCJhc3NpZ24iLCJ1bmRlZmluZWQiLCJzZWFyY2giLCJpbnB1dCIsInJlc3VsdHMiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scripts/airport.js\n");

/***/ }),

/***/ "./src/scripts/flight.js":
/*!*******************************!*\
  !*** ./src/scripts/flight.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateTime: function() { return /* binding */ calculateTime; },\n/* harmony export */   getAircraft: function() { return /* binding */ getAircraft; },\n/* harmony export */   getAirportArrivals: function() { return /* binding */ getAirportArrivals; },\n/* harmony export */   getAirportDepartures: function() { return /* binding */ getAirportDepartures; },\n/* harmony export */   getAllFlights: function() { return /* binding */ getAllFlights; },\n/* harmony export */   getFlightLocation: function() { return /* binding */ getFlightLocation; }\n/* harmony export */ });\nlet allFlights;\nlet arrivalFlights;\nlet departureFlights;\nlet aircraftFlights;\nlet flightLocations;\nconst url = \"https://opensky-network.org/api/flights/\";\n\n// track gives back last reported location of an airplane\nconst getFlightLocation = async function (icao24) {\n  let time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  try {\n    const res = await fetch(`https://opensky-network.org/api/tracks/all?icao24=${icao24}&time=${time}`, {\n      headers: {\n        'Accept': 'application/json'\n      }\n    });\n    if (res.ok) {\n      const data = await res.json();\n      const lastLocation = data.path[data.path.length - 1];\n      // console.log(\"Last reported Latitude:\" , lastLocation[1]);\n      // console.log(\"Last reported Longitude:\" , lastLocation[2]);\n      console.log(data.path);\n      return data.path;\n    } else {\n      throw new Error('response not ok');\n    }\n  } catch (error) {\n    console.error('Error fetching data', error);\n  }\n};\n// Get all flights between time frame < 2 hrs\nconst getAllFlights = async (begin, end) => {\n  // beginning and ending in unix time, seconds since epoch\n  try {\n    const res = await fetch(url + `all?begin=${begin}&end=${end}`, {\n      headers: {\n        'Accept': 'application/json'\n      }\n    });\n    if (res.ok) {\n      const data = await res.json();\n      allFlights = data;\n      return data;\n    } else {\n      throw new Error('response not ok');\n    }\n  } catch (error) {\n    console.error('Error fetching data', error);\n  }\n};\n\n// Get flight information for aircraft departed and arrived within time frame < 30 days, \nconst getAircraft = async (icao24, begin, end) => {\n  try {\n    const res = await fetch(url + `aircraft?icao24=${icao24}&begin=${begin}&end=${end}`, {\n      headers: {\n        'Accept': 'application/json'\n      }\n    });\n    if (res.ok) {\n      const data = await res.json();\n      aircraftFlights = data;\n      return data;\n    } else {\n      throw new Error('response not ok');\n    }\n  } catch (error) {\n    console.error('Error fetching aircraft', error);\n  }\n};\n\n// Get all airport arrivals at specific airport, time frame < 1 week, arrival data from previous day or earlier\nconst getAirportArrivals = async (airport, begin, end) => {\n  try {\n    const res = await fetch(url + `arrival?airport=${airport}&begin=${begin}&end=${end}`, {\n      headers: {\n        'Accept': 'application/json'\n      }\n    });\n    if (res.ok) {\n      const data = await res.json();\n      arrivalFlights = data;\n      return data;\n    } else {\n      throw new Error('response not ok');\n    }\n  } catch (error) {\n    console.error('Error fetching arrivals', error);\n  }\n};\n\n// Get all flight depatures at specific airport, time frame < 1 week, ALWAYS UP TO DATE\nconst getAirportDepartures = async (airport, begin, end) => {\n  try {\n    const res = await fetch(url + `departure?airport=${airport}&begin=${begin}&end=${end}`, {\n      headers: {\n        'Accept': 'application/json'\n      }\n    });\n    if (res.ok) {\n      const data = await res.json();\n      departureFlights = data;\n      return data;\n    } else {\n      throw new Error('response not ok');\n    }\n  } catch (error) {\n    console.error('Error fetching departures', error);\n  }\n};\n\n// convert user input time in hrs\nconst calculateTime = function () {\n  let time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return Math.floor(new Date() / 1000) - time * 3600;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGdCQUFnQixHQUFHYyxJQUFJO01BQ3ZCLE9BQU9BLElBQUk7SUFDWixDQUFDLE1BQU07TUFDTixNQUFNLElBQUlNLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQztJQUNuQztFQUNELENBQUMsQ0FBQyxPQUFNQyxLQUFLLEVBQUU7SUFDZEgsT0FBTyxDQUFDRyxLQUFLLENBQUMsMkJBQTJCLEVBQUVBLEtBQUssQ0FBQztFQUNsRDtBQUNELENBQUM7O0FBRUQ7QUFDTyxNQUFNUSxhQUFhLEdBQUcsU0FBQUEsQ0FBQSxFQUFjO0VBQUEsSUFBYnZCLElBQUksR0FBQUMsU0FBQSxDQUFBQyxNQUFBLFFBQUFELFNBQUEsUUFBQUUsU0FBQSxHQUFBRixTQUFBLE1BQUcsQ0FBQztFQUNyQyxPQUFPdUIsSUFBSSxDQUFDQyxLQUFLLENBQUMsSUFBSUMsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRzFCLElBQUksR0FBRyxJQUFJO0FBQ25ELENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za3l2aWV3Ly4vc3JjL3NjcmlwdHMvZmxpZ2h0LmpzPzlkNTAiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IGFsbEZsaWdodHM7XG5sZXQgYXJyaXZhbEZsaWdodHM7XG5sZXQgZGVwYXJ0dXJlRmxpZ2h0cztcbmxldCBhaXJjcmFmdEZsaWdodHM7XG5sZXQgZmxpZ2h0TG9jYXRpb25zO1xuXG5jb25zdCB1cmwgPSBcImh0dHBzOi8vb3BlbnNreS1uZXR3b3JrLm9yZy9hcGkvZmxpZ2h0cy9cIjtcblxuLy8gdHJhY2sgZ2l2ZXMgYmFjayBsYXN0IHJlcG9ydGVkIGxvY2F0aW9uIG9mIGFuIGFpcnBsYW5lXG5leHBvcnQgY29uc3QgZ2V0RmxpZ2h0TG9jYXRpb24gPSBhc3luYyhpY2FvMjQsIHRpbWUgPSAwKSA9PiB7XG5cdHRyeSB7XG5cdFx0Y29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vb3BlbnNreS1uZXR3b3JrLm9yZy9hcGkvdHJhY2tzL2FsbD9pY2FvMjQ9JHtpY2FvMjR9JnRpbWU9JHt0aW1lfWAgLCB7aGVhZGVyczoge1xuXHRcdFx0J0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuXHRcdH19KVxuXHRcdGlmKHJlcy5vaykge1xuXHRcdFx0Y29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG5cdFx0XHRjb25zdCBsYXN0TG9jYXRpb24gPSBkYXRhLnBhdGhbZGF0YS5wYXRoLmxlbmd0aCAtIDFdO1xuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJMYXN0IHJlcG9ydGVkIExhdGl0dWRlOlwiICwgbGFzdExvY2F0aW9uWzFdKTtcblx0XHRcdC8vIGNvbnNvbGUubG9nKFwiTGFzdCByZXBvcnRlZCBMb25naXR1ZGU6XCIgLCBsYXN0TG9jYXRpb25bMl0pO1xuXHRcdFx0Y29uc29sZS5sb2coZGF0YS5wYXRoKTtcblx0XHRcdHJldHVybiBkYXRhLnBhdGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcigncmVzcG9uc2Ugbm90IG9rJyk7XG5cdFx0fVxuXHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0Y29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZGF0YScsIGVycm9yKTtcblx0fVxufVxuLy8gR2V0IGFsbCBmbGlnaHRzIGJldHdlZW4gdGltZSBmcmFtZSA8IDIgaHJzXG5leHBvcnQgY29uc3QgZ2V0QWxsRmxpZ2h0cyA9IGFzeW5jIChiZWdpbiwgZW5kKSAgPT4ge1xuXHQvLyBiZWdpbm5pbmcgYW5kIGVuZGluZyBpbiB1bml4IHRpbWUsIHNlY29uZHMgc2luY2UgZXBvY2hcblx0dHJ5IHtcblx0XHRjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwgKyBgYWxsP2JlZ2luPSR7YmVnaW59JmVuZD0ke2VuZH1gLCB7aGVhZGVyczoge1xuXHRcdFx0J0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuXHRcdH19KTtcblx0XHRpZihyZXMub2spe1xuXHRcdFx0Y29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG5cdFx0XHRhbGxGbGlnaHRzID0gZGF0YTtcblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3Jlc3BvbnNlIG5vdCBvaycpO1xuXHRcdH1cblx0fSBjYXRjaChlcnJvcikge1xuXHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGRhdGEnLCBlcnJvcik7XG5cdH1cbn1cblxuLy8gR2V0IGZsaWdodCBpbmZvcm1hdGlvbiBmb3IgYWlyY3JhZnQgZGVwYXJ0ZWQgYW5kIGFycml2ZWQgd2l0aGluIHRpbWUgZnJhbWUgPCAzMCBkYXlzLCBcbmV4cG9ydCBjb25zdCBnZXRBaXJjcmFmdCA9IGFzeW5jKGljYW8yNCwgYmVnaW4sIGVuZCkgPT4ge1xuXHR0cnkge1xuXHRcdGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCArIGBhaXJjcmFmdD9pY2FvMjQ9JHtpY2FvMjR9JmJlZ2luPSR7YmVnaW59JmVuZD0ke2VuZH1gLCB7aGVhZGVyczoge1xuXHRcdFx0J0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcblx0XHR9fSk7XG5cdFx0aWYocmVzLm9rKSB7XG5cdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcblx0XHRcdGFpcmNyYWZ0RmxpZ2h0cyA9IGRhdGE7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdyZXNwb25zZSBub3Qgb2snKTtcblx0XHR9XG5cdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhaXJjcmFmdCcsIGVycm9yKTtcblx0fVxufVxuXG4vLyBHZXQgYWxsIGFpcnBvcnQgYXJyaXZhbHMgYXQgc3BlY2lmaWMgYWlycG9ydCwgdGltZSBmcmFtZSA8IDEgd2VlaywgYXJyaXZhbCBkYXRhIGZyb20gcHJldmlvdXMgZGF5IG9yIGVhcmxpZXJcbmV4cG9ydCBjb25zdCBnZXRBaXJwb3J0QXJyaXZhbHMgPSBhc3luYyAoYWlycG9ydCwgYmVnaW4sIGVuZCkgPT4ge1xuXHR0cnkge1xuXHRcdGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCArIGBhcnJpdmFsP2FpcnBvcnQ9JHthaXJwb3J0fSZiZWdpbj0ke2JlZ2lufSZlbmQ9JHtlbmR9YCwge2hlYWRlcnM6IHtcblx0XHRcdCdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG5cdFx0fX0pO1xuXHRcdGlmKHJlcy5vaykge1xuXHRcdFx0Y29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCk7XG5cdFx0XHRhcnJpdmFsRmxpZ2h0cyA9IGRhdGE7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdyZXNwb25zZSBub3Qgb2snKTtcblx0XHR9XG5cdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhcnJpdmFscycsIGVycm9yKTtcblx0fVxufVxuXG4vLyBHZXQgYWxsIGZsaWdodCBkZXBhdHVyZXMgYXQgc3BlY2lmaWMgYWlycG9ydCwgdGltZSBmcmFtZSA8IDEgd2VlaywgQUxXQVlTIFVQIFRPIERBVEVcbmV4cG9ydCBjb25zdCBnZXRBaXJwb3J0RGVwYXJ0dXJlcyA9IGFzeW5jIChhaXJwb3J0LCBiZWdpbiwgZW5kKSA9PiB7XG5cdHRyeSB7XG5cdFx0Y29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsICsgYGRlcGFydHVyZT9haXJwb3J0PSR7YWlycG9ydH0mYmVnaW49JHtiZWdpbn0mZW5kPSR7ZW5kfWAsIHtoZWFkZXJzOiB7XG5cdFx0XHQnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuXHRcdH19KTtcblx0XHRpZihyZXMub2spIHtcblx0XHRcdGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuXHRcdFx0ZGVwYXJ0dXJlRmxpZ2h0cyA9IGRhdGE7XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdyZXNwb25zZSBub3Qgb2snKTtcblx0XHR9XG5cdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBkZXBhcnR1cmVzJywgZXJyb3IpO1xuXHR9XG59XG5cbi8vIGNvbnZlcnQgdXNlciBpbnB1dCB0aW1lIGluIGhyc1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVRpbWUgPSAodGltZSA9IDApID0+IHtcblx0cmV0dXJuIE1hdGguZmxvb3IobmV3IERhdGUoKSAvIDEwMDApIC0gdGltZSAqIDM2MDA7XG59XG5cblxuXG4iXSwibmFtZXMiOlsiYWxsRmxpZ2h0cyIsImFycml2YWxGbGlnaHRzIiwiZGVwYXJ0dXJlRmxpZ2h0cyIsImFpcmNyYWZ0RmxpZ2h0cyIsImZsaWdodExvY2F0aW9ucyIsInVybCIsImdldEZsaWdodExvY2F0aW9uIiwiaWNhbzI0IiwidGltZSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsInJlcyIsImZldGNoIiwiaGVhZGVycyIsIm9rIiwiZGF0YSIsImpzb24iLCJsYXN0TG9jYXRpb24iLCJwYXRoIiwiY29uc29sZSIsImxvZyIsIkVycm9yIiwiZXJyb3IiLCJnZXRBbGxGbGlnaHRzIiwiYmVnaW4iLCJlbmQiLCJnZXRBaXJjcmFmdCIsImdldEFpcnBvcnRBcnJpdmFscyIsImFpcnBvcnQiLCJnZXRBaXJwb3J0RGVwYXJ0dXJlcyIsImNhbGN1bGF0ZVRpbWUiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scripts/flight.js\n");

/***/ }),

/***/ "./src/scripts/map.js":
/*!****************************!*\
  !*** ./src/scripts/map.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addMap: function() { return /* binding */ addMap; },\n/* harmony export */   drawPath: function() { return /* binding */ drawPath; }\n/* harmony export */ });\nlet g;\nlet projection;\nlet airportLocation;\nconst addMap = (location, icao) => {\n  const height = 600;\n  const width = 800;\n  const svg = d3.select('#map').append('svg').attr('width', width).attr('height', height);\n  g = svg.append('g');\n  const handleZoom = e => {\n    g.attr('transform', e.transform);\n  };\n  let zoom = d3.zoom().scaleExtent([1, 80]).translateExtent([[0, 0], [width, height]]).on('zoom', handleZoom);\n  svg.call(zoom);\n  projection = d3.geoMercator().center([location[0], location[1]]).translate([width / 2, height / 2]).scale(120);\n  zoom.scaleTo(svg, 20);\n  const path = d3.geoPath().projection(projection);\n  d3.json('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json').then(data => {\n    const countries = topojson.feature(data, data.objects.countries);\n    const coordinates = projection(location);\n    airportLocation = coordinates;\n    g.selectAll('path').data(countries.features).enter().append('path').attr('d', path);\n    g.selectAll('circle').data(location).enter().append('circle').attr('cx', coordinates[0]).attr('cy', coordinates[1]).attr('r', .25).style('fill', '#000000');\n    g.selectAll('text').data(location).enter().append('text').attr('x', coordinates[0] + .5).attr('y', coordinates[1]).text(icao).style('font-size', '1px');\n  });\n};\nconst drawPath = async (path, plane) => {\n  // [time, latitude, longitude, baro_altitude, true_track, on_ground]\n  const waypoints = await path;\n  const coordinates = [];\n  coordinates.push(airportLocation);\n  waypoints.forEach(waypoint => {\n    coordinates.push(projection([waypoint[2], waypoint[1]]));\n  });\n\n  // path using circles\n  // g.selectAll('circle')\n  // \t.data(coordinates)\n  // \t.enter()\n  // \t.append('circle')\n  // \t.attr('cx', d => d[0])\n  // \t.attr('cy', d => d[1])\n  // \t.attr('r', .1)\n  // \t.style('fill', '#ffffff');\n\n  // path using line\n  const lineGenerator = d3.line().x(d => d[0]).y(d => d[1]);\n  g.append('path').data([coordinates]).attr('fill', 'none').style('stroke', '#000080').style('stroke-width', 0.1).attr('d', lineGenerator);\n  const lastLocation = coordinates[coordinates.length - 1];\n  const lastAngle = waypoints[waypoints.length - 1][4];\n  const landed = waypoints[waypoints.length - 1][5];\n  console.log('last angle', lastAngle);\n  console.log('landed', landed);\n  g.append('image').attr('xlink:href', '../../assets/plane.png').attr('width', 1).attr('height', 1).attr('x', lastLocation[0] - .5).attr('y', lastLocation[1] - .5).attr('transform', `rotate(${lastAngle}, ${lastLocation[0]}, ${lastLocation[1]})`);\n  g.append('text').attr('x', lastLocation[0] + .5).attr('y', lastLocation[1] + .5).text(plane) // `${plane} landed: ${landed}`\n  .style('font-size', '.75px');\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsQ0FBQyxDQUFFLEdBQUUsQ0FBQztFQUVuRnBELENBQUMsQ0FBQ1csTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUNkQyxJQUFJLENBQUMsR0FBRyxFQUFFd0MsWUFBWSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUMvQnhDLElBQUksQ0FBQyxHQUFHLEVBQUV3QyxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQy9CWixJQUFJLENBQUNFLEtBQUssQ0FBQyxDQUFDO0VBQUEsQ0FDWkgsS0FBSyxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUM7QUFDOUIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NreXZpZXcvLi9zcmMvc2NyaXB0cy9tYXAuanM/ZjU2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgZztcbmxldCBwcm9qZWN0aW9uO1xubGV0IGFpcnBvcnRMb2NhdGlvbjtcbmV4cG9ydCBjb25zdCBhZGRNYXAgPSAobG9jYXRpb24sIGljYW8pID0+IHtcblx0Y29uc3QgaGVpZ2h0ID0gNjAwO1xuXHRjb25zdCB3aWR0aCA9IDgwMDtcblxuXHRjb25zdCBzdmcgPSBkMy5zZWxlY3QoJyNtYXAnKVxuXHRcdC5hcHBlbmQoJ3N2ZycpXG5cdFx0LmF0dHIoJ3dpZHRoJywgd2lkdGgpXG5cdFx0LmF0dHIoJ2hlaWdodCcsIGhlaWdodClcblxuXHRnID0gc3ZnLmFwcGVuZCgnZycpO1xuXHRcblx0Y29uc3QgaGFuZGxlWm9vbSA9IChlKSA9PiB7XG5cdFx0Zy5hdHRyKCd0cmFuc2Zvcm0nLCBlLnRyYW5zZm9ybSk7XG5cdH1cblxuXHRsZXQgem9vbSA9IGQzLnpvb20oKVxuXHRcdC5zY2FsZUV4dGVudChbMSwgODBdKVxuXHRcdC50cmFuc2xhdGVFeHRlbnQoW1swLCAwXSwgW3dpZHRoLCBoZWlnaHRdXSlcblx0XHQub24oJ3pvb20nLCBoYW5kbGVab29tKTtcblx0XG5cdHN2Zy5jYWxsKHpvb20pO1xuXG5cdHByb2plY3Rpb24gPSBkMy5nZW9NZXJjYXRvcigpXG5cdFx0LmNlbnRlcihbbG9jYXRpb25bMF0sIGxvY2F0aW9uWzFdXSlcblx0XHQudHJhbnNsYXRlKFt3aWR0aCAvIDIsIGhlaWdodCAvIDJdKVxuXHRcdC5zY2FsZSgxMjApO1xuXG5cdHpvb20uc2NhbGVUbyhzdmcsIDIwKTtcblx0XG5cdGNvbnN0IHBhdGggPSBkMy5nZW9QYXRoKClcblx0XHQucHJvamVjdGlvbihwcm9qZWN0aW9uKTtcblx0XG5cdGQzLmpzb24oJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vd29ybGQtYXRsYXNAMi9jb3VudHJpZXMtMTEwbS5qc29uJylcblx0XHQudGhlbihkYXRhID0+IHtcblx0XHRcdGNvbnN0IGNvdW50cmllcyA9IHRvcG9qc29uLmZlYXR1cmUoZGF0YSwgZGF0YS5vYmplY3RzLmNvdW50cmllcyk7XG5cdFx0XHRjb25zdCBjb29yZGluYXRlcyA9IHByb2plY3Rpb24obG9jYXRpb24pO1xuXHRcdFx0YWlycG9ydExvY2F0aW9uID0gY29vcmRpbmF0ZXM7XG5cdFx0XHRnLnNlbGVjdEFsbCgncGF0aCcpXG5cdFx0XHRcdC5kYXRhKGNvdW50cmllcy5mZWF0dXJlcylcblx0XHRcdFx0LmVudGVyKClcblx0XHRcdFx0LmFwcGVuZCgncGF0aCcpXG5cdFx0XHRcdC5hdHRyKCdkJywgcGF0aClcblx0XHRcdFxuXHRcdFx0Zy5zZWxlY3RBbGwoJ2NpcmNsZScpXG5cdFx0XHRcdC5kYXRhKGxvY2F0aW9uKVxuXHRcdFx0XHQuZW50ZXIoKVxuXHRcdFx0XHQuYXBwZW5kKCdjaXJjbGUnKVxuXHRcdFx0XHQuYXR0cignY3gnLCBjb29yZGluYXRlc1swXSlcblx0XHRcdFx0LmF0dHIoJ2N5JywgY29vcmRpbmF0ZXNbMV0pXG5cdFx0XHRcdC5hdHRyKCdyJywgLjI1KVxuXHRcdFx0XHQuc3R5bGUoJ2ZpbGwnLCAnIzAwMDAwMCcpO1xuXG5cdFx0XHRnLnNlbGVjdEFsbCgndGV4dCcpXG5cdFx0XHRcdC5kYXRhKGxvY2F0aW9uKVxuXHRcdFx0XHQuZW50ZXIoKVxuXHRcdFx0XHQuYXBwZW5kKCd0ZXh0Jylcblx0XHRcdFx0LmF0dHIoJ3gnLCBjb29yZGluYXRlc1swXSArIC41KVxuXHRcdFx0XHQuYXR0cigneScsIGNvb3JkaW5hdGVzWzFdKVxuXHRcdFx0XHQudGV4dChpY2FvKVxuXHRcdFx0XHQuc3R5bGUoJ2ZvbnQtc2l6ZScsICcxcHgnKTtcblx0XHR9KTtcdFxufVxuXG5leHBvcnQgY29uc3QgZHJhd1BhdGggPSBhc3luYyhwYXRoLCBwbGFuZSkgPT4ge1xuXHQvLyBbdGltZSwgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgYmFyb19hbHRpdHVkZSwgdHJ1ZV90cmFjaywgb25fZ3JvdW5kXVxuXHRjb25zdCB3YXlwb2ludHMgPSBhd2FpdCBwYXRoO1xuXHRjb25zdCBjb29yZGluYXRlcyA9IFtdO1xuXHRjb29yZGluYXRlcy5wdXNoKGFpcnBvcnRMb2NhdGlvbik7XG5cdHdheXBvaW50cy5mb3JFYWNoKCh3YXlwb2ludCkgPT4ge1xuXHRcdGNvb3JkaW5hdGVzLnB1c2gocHJvamVjdGlvbihbd2F5cG9pbnRbMl0sIHdheXBvaW50WzFdXSkpO1xuXHR9KVxuXHRcblx0Ly8gcGF0aCB1c2luZyBjaXJjbGVzXG5cdC8vIGcuc2VsZWN0QWxsKCdjaXJjbGUnKVxuXHQvLyBcdC5kYXRhKGNvb3JkaW5hdGVzKVxuXHQvLyBcdC5lbnRlcigpXG5cdC8vIFx0LmFwcGVuZCgnY2lyY2xlJylcblx0Ly8gXHQuYXR0cignY3gnLCBkID0+IGRbMF0pXG5cdC8vIFx0LmF0dHIoJ2N5JywgZCA9PiBkWzFdKVxuXHQvLyBcdC5hdHRyKCdyJywgLjEpXG5cdC8vIFx0LnN0eWxlKCdmaWxsJywgJyNmZmZmZmYnKTtcblx0XG5cdC8vIHBhdGggdXNpbmcgbGluZVxuXHRjb25zdCBsaW5lR2VuZXJhdG9yID0gZDMubGluZSgpXG5cdFx0LngoZCA9PiBkWzBdKVxuXHRcdC55KGQgPT4gZFsxXSk7XG5cblx0Zy5hcHBlbmQoJ3BhdGgnKVxuXHRcdC5kYXRhKFtjb29yZGluYXRlc10pXG5cdFx0LmF0dHIoJ2ZpbGwnLCAnbm9uZScpXG5cdFx0LnN0eWxlKCdzdHJva2UnLCAnIzAwMDA4MCcpXG5cdFx0LnN0eWxlKCdzdHJva2Utd2lkdGgnLCAwLjEpXG5cdFx0LmF0dHIoJ2QnLCBsaW5lR2VuZXJhdG9yKVxuXG5cdGNvbnN0IGxhc3RMb2NhdGlvbiA9IGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDFdO1xuXHRjb25zdCBsYXN0QW5nbGUgPSB3YXlwb2ludHNbd2F5cG9pbnRzLmxlbmd0aCAtIDFdWzRdO1xuXHRjb25zdCBsYW5kZWQgPSB3YXlwb2ludHNbd2F5cG9pbnRzLmxlbmd0aCAtIDFdWzVdO1xuXHRjb25zb2xlLmxvZygnbGFzdCBhbmdsZScsIGxhc3RBbmdsZSk7XG5cdGNvbnNvbGUubG9nKCdsYW5kZWQnLCBsYW5kZWQpO1xuXG5cdGcuYXBwZW5kKCdpbWFnZScpXG5cdFx0LmF0dHIoJ3hsaW5rOmhyZWYnLCAnLi4vLi4vYXNzZXRzL3BsYW5lLnBuZycpXG5cdFx0LmF0dHIoJ3dpZHRoJywgMSlcblx0XHQuYXR0cignaGVpZ2h0JywgMSlcblx0XHQuYXR0cigneCcsIGxhc3RMb2NhdGlvblswXSAtIC41KVxuXHRcdC5hdHRyKCd5JywgbGFzdExvY2F0aW9uWzFdIC0gLjUpXG5cdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGByb3RhdGUoJHtsYXN0QW5nbGV9LCAke2xhc3RMb2NhdGlvblswXX0sICR7bGFzdExvY2F0aW9uWzFdfSlgKTtcblx0XG5cdGcuYXBwZW5kKCd0ZXh0Jylcblx0XHQuYXR0cigneCcsIGxhc3RMb2NhdGlvblswXSArIC41KVxuXHRcdC5hdHRyKCd5JywgbGFzdExvY2F0aW9uWzFdICsgLjUpXG5cdFx0LnRleHQocGxhbmUpIC8vIGAke3BsYW5lfSBsYW5kZWQ6ICR7bGFuZGVkfWBcblx0XHQuc3R5bGUoJ2ZvbnQtc2l6ZScsICcuNzVweCcpO1xufSJdLCJuYW1lcyI6WyJnIiwicHJvamVjdGlvbiIsImFpcnBvcnRMb2NhdGlvbiIsImFkZE1hcCIsImxvY2F0aW9uIiwiaWNhbyIsImhlaWdodCIsIndpZHRoIiwic3ZnIiwiZDMiLCJzZWxlY3QiLCJhcHBlbmQiLCJhdHRyIiwiaGFuZGxlWm9vbSIsImUiLCJ0cmFuc2Zvcm0iLCJ6b29tIiwic2NhbGVFeHRlbnQiLCJ0cmFuc2xhdGVFeHRlbnQiLCJvbiIsImNhbGwiLCJnZW9NZXJjYXRvciIsImNlbnRlciIsInRyYW5zbGF0ZSIsInNjYWxlIiwic2NhbGVUbyIsInBhdGgiLCJnZW9QYXRoIiwianNvbiIsInRoZW4iLCJkYXRhIiwiY291bnRyaWVzIiwidG9wb2pzb24iLCJmZWF0dXJlIiwib2JqZWN0cyIsImNvb3JkaW5hdGVzIiwic2VsZWN0QWxsIiwiZmVhdHVyZXMiLCJlbnRlciIsInN0eWxlIiwidGV4dCIsImRyYXdQYXRoIiwicGxhbmUiLCJ3YXlwb2ludHMiLCJwdXNoIiwiZm9yRWFjaCIsIndheXBvaW50IiwibGluZUdlbmVyYXRvciIsImxpbmUiLCJ4IiwiZCIsInkiLCJsYXN0TG9jYXRpb24iLCJsZW5ndGgiLCJsYXN0QW5nbGUiLCJsYW5kZWQiLCJjb25zb2xlIiwibG9nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/scripts/map.js\n");

/***/ }),

/***/ "./src/index.scss":
/*!************************!*\
  !*** ./src/index.scss ***!
  \************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguc2NzcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9za3l2aWV3Ly4vc3JjL2luZGV4LnNjc3M/OTc0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.scss\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ (function(module) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; };\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) });\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: true });\n  defineProperty(\n    GeneratorFunctionPrototype,\n    \"constructor\",\n    { value: GeneratorFunction, configurable: true }\n  );\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    defineProperty(this, \"_invoke\", { value: enqueue });\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var methodName = context.method;\n    var method = delegate.iterator[methodName];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method, or a missing .next mehtod, always terminate the\n      // yield* loop.\n      context.delegate = null;\n\n      // Note: [\"return\"] must be used for ES3 parsing compatibility.\n      if (methodName === \"throw\" && delegate.iterator[\"return\"]) {\n        // If the delegate iterator has a return method, give it a\n        // chance to clean up.\n        context.method = \"return\";\n        context.arg = undefined;\n        maybeInvokeDelegate(delegate, context);\n\n        if (context.method === \"throw\") {\n          // If maybeInvokeDelegate(context) changed context.method from\n          // \"return\" to \"throw\", let that override the TypeError below.\n          return ContinueSentinel;\n        }\n      }\n      if (methodName !== \"return\") {\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a '\" + methodName + \"' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(val) {\n    var object = Object(val);\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : 0\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLGlEQUFpRDs7QUFFNUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ04sZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1REFBdUQ7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBMEIsb0JBQW9CLENBQUU7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2t5dmlldy8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanM/OTZjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSwgZGVzYykgeyBvYmpba2V5XSA9IGRlc2MudmFsdWU7IH07XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGRlZmluZVByb3BlcnR5KGdlbmVyYXRvciwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgfSk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgZGVmaW5lUHJvcGVydHkoR3AsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgZGVmaW5lUHJvcGVydHkoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgXCJjb25zdHJ1Y3RvclwiLFxuICAgIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6IHRydWUgfVxuICApO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW52b2tlXCIsIHsgdmFsdWU6IGVucXVldWUgfSk7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kO1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kLCBvciBhIG1pc3NpbmcgLm5leHQgbWVodG9kLCBhbHdheXMgdGVybWluYXRlIHRoZVxuICAgICAgLy8geWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgIGlmIChtZXRob2ROYW1lID09PSBcInRocm93XCIgJiYgZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1ldGhvZE5hbWUgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbWV0aG9kTmFtZSArIFwiJyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciBvYmplY3QgPSBPYmplY3QodmFsKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	__webpack_require__("./src/index.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.scss");
/******/ 	
/******/ })()
;